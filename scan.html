<template>
  <div class="mesh-detail">
    <!-- Top action buttons: one left, one right -->
    <div class="top-buttons d-lg-flex d-sm-block justify-space-between align-center">
      <strong class="text-h6 font-weight-bold text-uppercase text-blue-grey-darken-4">
          status : 
          <span :class="master_status === 'online' ? 'text-teal' : 'text-red-darken-2'">
            {{ master_status }}
          </span>
        </strong>
      <div>
        <v-btn
          outlined
          @click="scanNodes"
          style="background-color: #a2af9b; color: black"
          class="font-weight-bold text-subtitle-1 text-blue-grey-darken-4 mr-4"
        >
          SCAN
        </v-btn>

        <v-btn
        color="red-darken-1"
        outlined
        @click="deleteAllNodes"
        class="font-weight-bold text-subtitle-1"
      >
        RESET !
      </v-btn>
      </div>
    </div>

    <!-- Nodes displayed inline (only mesh_slave: false) -->
    <div class="nodes-container pa-4 rounded-lg" style="background-color: #a2af9b;">
      <div
        v-for="(node, index) in nodes_detected.filter(n => !n.mesh_slave)"
        :key="index"
        class="node-item"
      >
        <!-- Dialog wrapping node button -->
        <v-dialog
          v-model="node.active"
          transition="dialog-bottom-transition"
          class="w-auto"
          style="max-width: 400px;"
        >
          <template v-slot:activator="{ props: activatorProps }">
            <v-btn
              v-bind="activatorProps"
              class="pt-2 pb-2"
              color="primary"
              outlined
            >
            <div class="d-lg-flex d-xs-block">
              <div class="mr-lg-4">
                Node Name: {{ node.display_name }}
                <br /><br />
                MAC Addr: {{ node.mac_address }}
              </div>
              <!-- Delete button stays on card -->
              <v-btn
                color="red-darken-1"
                small
                class=""
                @click.stop="deleteNode(index)"
              >
                Delete
              </v-btn>
            </div>
            </v-btn>
          </template>

          <!-- Popup content -->
          <v-card>
            <v-toolbar title="New Slave" style="background-color: #a2af9b;"></v-toolbar>

            <v-card-text>
              <p class="mb-2"><strong>Node Name:</strong> {{ node.display_name }}</p>
              <p class="mb-2"><strong>MAC Address:</strong> {{ node.mac_address }}</p>
              <p>
                <strong>Description:</strong>
                <v-text-field v-model="description" label="Description" outlined class="mt-2"></v-text-field>
              </p>
            </v-card-text>

            <v-card-actions class="justify-space-between">
              <v-btn
                @click="addSlave(node)"
                style="background-color: #a2af9b; color: black"
              >
                Create
              </v-btn>

              <v-btn
                @click="node.active = false"
                style="background-color: #90a4ae; color: black"
              >
                Close
              </v-btn>
            </v-card-actions>
          </v-card>
        </v-dialog>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  props: {
    msg: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      nodes_detected: [],
      description: "",
      master_status: "offline",
      ping_delay: 0,
      ping_reqest: false, // filter msg ping
      scan_reqest: false, // filter msg scan
    };
  },
  mounted() {
    // invoke logic function
    this.checkStatus();
    this.scanNodes();

    // Load saved nodes from localStorage
    const savedNodes = localStorage.getItem("nodes_detected");
    if (savedNodes) {
      try {
        this.nodes_detected = JSON.parse(savedNodes).map(n => ({
          ...n,
          active: false, // ensure active property exists
        }));
      } catch (e) {
        console.error("Failed to parse nodes_detected from localStorage", e);
      }
    }

    if (localStorage.getItem("loggedIn") === "false") {
      this.redirectLogin();
    }
  },
  watch: {
    msg: {
      handler(newMsg) {
        // node scan res handler
        if (newMsg && newMsg.scan && this.scan_reqest) {
          const payload = { ...newMsg.payload };
          payload.result.forEach(item => {
            const node = { 
              ...item, 
              mesh_slave: false, 
              active: false 
            };

            const exists = this.nodes_detected.some(
              n => n.mac_address === node.mac_address && n.display_name === node.display_name
            );

            if (!exists) {
              this.nodes_detected.push(node);
              console.log("New node detected:", node);
            }
          });
          this.scan_reqest = false; 
        }

        // pong handler
        if (newMsg && newMsg.pong && this.ping_reqest) {
          this.master_status = "online"
          if (this.ping_delay < 2) {
            this.ping_delay += 2;
          }
          this.ping_reqest = false; 
        }
      },
      deep: true
    }
  },
  methods: {
    redirectLogin() {
      const base = window.location.origin;
      window.location.href = `${base}/dashboard/login`;
    },
    deleteNode(index) {
      this.nodes_detected.splice(index, 1);
      localStorage.setItem(
        "nodes_detected",
        JSON.stringify(this.nodes_detected)
      );
    },
    deleteAllNodes() {
      if (confirm("Are you sure you want to delete all nodes?")) {
        this.nodes_detected = [];
        localStorage.removeItem("nodes_detected");
        const sendObj = {
          collection: "nodes",
          operation: "drop",
          toMongo: true
        };
        this.send(sendObj);
      }
    },
    addSlave(node) {
      // Close the dialog
      node.active = false;

      const sendObj = {
        collection: "nodes",
        payload: { 
          description: this.description, 
          display_name: node.display_name,
          mac_address: node.mac_address
        },
        operation: "insertOne",
        toMongo: true
      };
      this.send(sendObj);

      // Set mesh_slave = true so it no longer appears in scan section
      const targetNode = this.nodes_detected.find(
        n => n.ip_address === node.ip_address && n.name === node.name
      );
      if (targetNode) {
        targetNode.mesh_slave = true;
        localStorage.setItem("nodes_detected", JSON.stringify(this.nodes_detected));
      }
    },
    checkStatus() {
      // send ping payload to master node
      setInterval(() => {
      const sendObj = {
        payload: "ping"
      };
      this.ping_reqest = true; 
      // online & offline logic
      if (this.ping_delay == 0) {
        this.master_status = "offline";
      } else {
        this.master_status = "online";
        this.ping_delay -= 1;
      }
      this.send(sendObj);
      }, 1000); // 1000 ms = 1 second
    },
    scanNodes() {
      const sendObj = {
        payload: "scan"
      };
      this.scan_reqest = true; 
      this.send(sendObj);
    }
  },
};
</script>

<style scoped>
.top-buttons {
  margin: 10px;
}

.mesh-detail {
  display: flex;
  flex-direction: column;
  margin: 10px;
}

.nodes-container {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.node-item {
  display: inline-block;
}
</style>

